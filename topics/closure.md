## Что такое замыкание?

**Замыкание** — это функция, которая имеет доступ к переменным из своей внешней области видимости, даже после того, как эта внешняя функция завершила выполнение.

Проще говоря, замыкание — это функция, которая запоминает переменные из того места, где она была создана.

---

## Пример замыкания

Давай рассмотрим простой пример:

```javascript
function createCounter() {
    let count = 0;  // Локальная переменная

    return function() {
        count++;  // Увеличиваем значение переменной
        console.log(count);
    };
}

const counter = createCounter();  // Создаем замыкание
counter();  // 1
counter();  // 2
counter();  // 3
```

**Объяснение:**
1. Функция `createCounter` возвращает другую функцию.
2. Возвращаемая функция имеет доступ к переменной `count`, которая находится во внешней функции `createCounter`.
3. Даже после того, как `createCounter` завершила выполнение, возвращаемая функция по-прежнему имеет доступ к переменной `count`.

---

## Как работает замыкание?

Когда функция создается внутри другой функции, она запоминает свое окружение (переменные, параметры и т.д.). Это окружение называется **лексическим окружением**.

В примере выше:
- `count` — это переменная из лексического окружения функции `createCounter`.
- Возвращаемая функция "замыкает" эту переменную, сохраняя ее значение между вызовами.

---

## Зачем нужны замыкания?

Замыкания используются для:
1. **Создания приватных переменных.**
2. **Создания функций с "памятью".**
3. **Реализации инкапсуляции.**

---

## Пример с приватной переменной

Замыкания позволяют создавать переменные, которые недоступны извне, но могут быть использованы внутри функций.

```javascript
function createBankAccount(initialBalance) {
    let balance = initialBalance;  // Приватная переменная

    return {
        deposit: function(amount) {
            balance += amount;
            console.log("Баланс после пополнения:", balance);
        },
        withdraw: function(amount) {
            if (amount > balance) {
                console.log("Недостаточно средств!");
                return;
            }
            balance -= amount;
            console.log("Баланс после снятия:", balance);
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
account.deposit(50);  // Баланс после пополнения: 150
account.withdraw(30);  // Баланс после снятия: 120
console.log(account.getBalance());  // 120
```

**Объяснение:**
- Переменная `balance` недоступна извне, но функции `deposit`, `withdraw` и `getBalance` имеют к ней доступ через замыкание.
- Это позволяет скрыть данные и защитить их от нежелательного изменения.

---

## Практика

Давай попробуем написать несколько примеров с использованием замыканий.

### Задача 1: Создать счетчик
Напиши функцию `createCounter`, которая возвращает объект с двумя методами:
- `increment()` — увеличивает значение счетчика на 1.
- `decrement()` — уменьшает значение счетчика на 1.
- `getValue()` — возвращает текущее значение счетчика.

**Пример использования:**
```javascript
const counter = createCounter(10);
counter.increment();  // 11
counter.increment();  // 12
counter.decrement();  // 11
console.log(counter.getValue());  // 11
```

---

### Задача 2: Создать функцию с "памятью"
Напиши функцию `createMultiplier`, которая принимает число `x` и возвращает функцию. Возвращаемая функция принимает число `y` и возвращает произведение `x * y`.

**Пример использования:**
```javascript
const multiplyByTwo = createMultiplier(2);
console.log(multiplyByTwo(5));  // 10
console.log(multiplyByTwo(10));  // 20
```

---

### Задача 3: Создать функцию для генерации уникальных идентификаторов
Напиши функцию `createIdGenerator`, которая возвращает функцию. Возвращаемая функция при каждом вызове возвращает уникальный идентификатор (начиная с 1 и увеличивая на 1).

**Пример использования:**
```javascript
const generateId = createIdGenerator();
console.log(generateId());  // 1
console.log(generateId());  // 2
console.log(generateId());  // 3
```
